âœ… HashSet vs TreeSet:
| Feature                  | **HashSet**                        | **TreeSet**                                               |
| ------------------------ | ---------------------------------- | --------------------------------------------------------- |
| **Ordering**             | âŒ No guaranteed order              | âœ… Sorted in **natural order** or with a comparator        |
| **Performance**          | âœ… Faster (O(1) for basic ops)      | â— Slower (O(log n) for basic ops)                         |
| **Underlying structure** | Uses a **HashMap** internally      | Uses a **Red-Black Tree** internally                      |
| **Null elements**        | âœ… Allows **one** null element      | âŒ Does **not** allow null (throws `NullPointerException`) |
| **Implements**           | `Set`, `Cloneable`, `Serializable` | `NavigableSet`, `SortedSet`, `Set`, etc.                  |
| **Use case**             | When you need **fast access**      | When you need **sorted elements**                         |


ğŸ§  Simple Example:
âœ… HashSet:

Set<String> hashSet = new HashSet<>();
hashSet.add("Banana");
hashSet.add("Apple");
hashSet.add("Orange");

System.out.println(hashSet); // Output order is unpredictable
âœ… TreeSet:

Set<String> treeSet = new TreeSet<>();
treeSet.add("Banana");
treeSet.add("Apple");
treeSet.add("Orange");

System.out.println(treeSet); // Output: [Apple, Banana, Orange]
âœ… Summary:
Use HashSet if you donâ€™t care about order and want fast operations.

Use TreeSet if you need elements in sorted order.